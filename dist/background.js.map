{"version":3,"file":"background.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://website-blocker/./src/background.ts"],"sourcesContent":["\"use strict\";\n// Background service worker for Website Blocker\n// Track if we're currently updating rules to prevent conflicts\nlet isUpdatingRules = false;\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('Website Blocker installed');\n    // Initialize default settings\n    chrome.storage.sync.set({\n        isBlocking: true,\n        websites: ['instagram.com', 'twitter.com', 'facebook.com', 'youtube.com'],\n        schedule: {\n            days: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n            startTime: '09:00',\n            endTime: '17:00'\n        }\n    });\n});\n// Listen for storage changes and update blocking rules\nchrome.storage.onChanged.addListener((changes, namespace) => {\n    if (namespace === 'sync') {\n        updateBlockingRules();\n    }\n});\n// Update blocking rules based on current settings\nasync function updateBlockingRules() {\n    // Prevent multiple simultaneous updates\n    if (isUpdatingRules) {\n        console.log('Already updating rules, skipping...');\n        return;\n    }\n    isUpdatingRules = true;\n    try {\n        const data = await chrome.storage.sync.get(['isBlocking', 'websites', 'schedule']);\n        const { isBlocking, websites, schedule } = data;\n        // Always clear ALL existing dynamic rules first\n        const existingRules = await chrome.declarativeNetRequest.getDynamicRules();\n        console.log('Clearing', existingRules.length, 'existing rules');\n        if (existingRules.length > 0) {\n            const ruleIdsToRemove = existingRules.map(rule => rule.id);\n            await chrome.declarativeNetRequest.updateDynamicRules({\n                removeRuleIds: ruleIdsToRemove\n            });\n            console.log('Cleared all existing rules');\n        }\n        // If blocking is disabled or outside schedule, don't add any rules\n        if (!isBlocking || !shouldBlockNow(schedule)) {\n            console.log('Blocking disabled or outside schedule - no rules added');\n            return;\n        }\n        // Create multiple blocking rules for each website to catch variations\n        const rules = [];\n        let ruleId = 1; // Start fresh with ID 1\n        websites.forEach((website) => {\n            // Pattern 1: Block with subdomain wildcard (*.example.com)\n            rules.push({\n                id: ruleId++,\n                priority: 1,\n                action: {\n                    type: 'redirect',\n                    redirect: {\n                        extensionPath: `/blocked.html?url=${encodeURIComponent(website)}`\n                    }\n                },\n                condition: {\n                    urlFilter: `*://*.${website}/*`,\n                    resourceTypes: ['main_frame']\n                }\n            });\n            // Pattern 2: Block without subdomain wildcard (example.com)\n            rules.push({\n                id: ruleId++,\n                priority: 1,\n                action: {\n                    type: 'redirect',\n                    redirect: {\n                        extensionPath: `/blocked.html?url=${encodeURIComponent(website)}`\n                    }\n                },\n                condition: {\n                    urlFilter: `*://${website}/*`,\n                    resourceTypes: ['main_frame']\n                }\n            });\n            // Pattern 3: Block exact domain\n            rules.push({\n                id: ruleId++,\n                priority: 1,\n                action: {\n                    type: 'redirect',\n                    redirect: {\n                        extensionPath: `/blocked.html?url=${encodeURIComponent(website)}`\n                    }\n                },\n                condition: {\n                    urlFilter: `*://${website}`,\n                    resourceTypes: ['main_frame']\n                }\n            });\n            // Pattern 4: Block with www\n            rules.push({\n                id: ruleId++,\n                priority: 1,\n                action: {\n                    type: 'redirect',\n                    redirect: {\n                        extensionPath: `/blocked.html?url=${encodeURIComponent(website)}`\n                    }\n                },\n                condition: {\n                    urlFilter: `*://www.${website}/*`,\n                    resourceTypes: ['main_frame']\n                }\n            });\n        });\n        if (rules.length > 0) {\n            console.log('Adding', rules.length, 'new rules');\n            await chrome.declarativeNetRequest.updateDynamicRules({\n                addRules: rules\n            });\n            console.log('Successfully added', rules.length, 'blocking rules for', websites.length, 'websites');\n        }\n    }\n    catch (error) {\n        console.error('Error updating blocking rules:', error);\n        // If we get a duplicate ID error, try clearing everything and starting over\n        if (error instanceof Error && error.message.includes('unique ID')) {\n            console.log('Duplicate ID error - clearing all rules and retrying...');\n            try {\n                // Force clear all rules\n                const allRules = await chrome.declarativeNetRequest.getDynamicRules();\n                if (allRules.length > 0) {\n                    await chrome.declarativeNetRequest.updateDynamicRules({\n                        removeRuleIds: allRules.map(rule => rule.id)\n                    });\n                }\n                console.log('Force cleared all rules due to ID conflict');\n            }\n            catch (clearError) {\n                console.error('Error force clearing rules:', clearError);\n            }\n        }\n    }\n    finally {\n        isUpdatingRules = false;\n    }\n}\n// Check if we should block websites based on current time and schedule\nfunction shouldBlockNow(schedule) {\n    if (!schedule)\n        return false;\n    const now = new Date();\n    const currentDay = now.toLocaleDateString('en-US', { weekday: 'long' });\n    const currentTime = now.getHours() * 60 + now.getMinutes(); // minutes since midnight\n    // Check if today is in the scheduled days\n    if (!schedule.days.includes(currentDay)) {\n        return false;\n    }\n    // Parse start and end times\n    const [startHour, startMinute] = schedule.startTime.split(':').map(Number);\n    const [endHour, endMinute] = schedule.endTime.split(':').map(Number);\n    const startTime = startHour * 60 + startMinute;\n    const endTime = endHour * 60 + endMinute;\n    // Check if current time is within the blocking window\n    return currentTime >= startTime && currentTime <= endTime;\n}\n// Listen for messages from popup\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    if (request.action === 'updateBlocking') {\n        updateBlockingRules().then(() => {\n            sendResponse({ success: true });\n        }).catch((error) => {\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Will respond asynchronously\n    }\n    else if (request.action === 'getStatus') {\n        chrome.storage.sync.get(['isBlocking', 'websites', 'schedule']).then((data) => {\n            sendResponse({\n                ...data,\n                shouldBlock: shouldBlockNow(data.schedule)\n            });\n        });\n        return true; // Will respond asynchronously\n    }\n});\n// Update rules when the extension starts\nupdateBlockingRules();\n"],"names":[],"sourceRoot":""}